# README #

`proftool` is a utility for capturing and examining profiles of Java
programs.  It's intended to provide machine level details about the execution to
aid with JIT performance analysis.  It currently consists of three primary components:

* a JVMTI agent for capturing all the assembly generated by the JVM.
* a parser for Linux perf output
* a parser for HotSpot LogCompilation information

By combining these components into a single command line, the perf
profile information can be attributed to the JIT code.

This suite must be built first to create the JVMTI agent library and the suite is normally dynamically
imported to make the commands available through mx.

### Recording a profile

There are currently 2 ways to capture profiles.  The direct way is to use the `profrecord` command
which takes a full Java command line as an argument and launches it with extra arguments
to collect the data.

```
$ mx profrecord -E fop /home/graal/oraclejdk1.8.0_291-jvmci-21.1-b03/bin/java -jar dacapo.jar fop -n 56
```

The second and simplest way is to use the `proftool` profiler with the `mx benchmark` command.  The `proftool` profiler
conflicts with the `rss` tracker which is enabled by default, so it must be explicitly turned off.  For example, running:

```
$ mx benchmark dacapo:fop --tracker none -- --profiler proftool
```

produces a uniquely named directory like `proftool_fop_2021-07-11_181530` which contains a profile of the full
benchmark run.  After capturing the profile, the perf binary output needs to be converted to text
using the `profpackage` command.

```
$ mx profpackage proftool_fop_2021-07-11_181530
Created /home/graal/ws/graal/compiler/proftool_fop_2021-07-11_181530.zip
```

This command additionally packs everything into a zip to make it easy to pass profiles around.
The zip can be used directly by all the `proftool` commands.

### Examining a profile.

Profile collection currently only supports Linux perf once the data is captured then the profile can
be viewed anywhere.  The primary command for examining profiles is `profhot`.  This gives a summary
of the top C functions and the top JIT methods.  The JIT methods are additionally disassembled and
annotated with the profile information.  Truncated sample output looks like this:

```
$ mx profhot proftool_fop_2021-07-11_181530.zip
Hot C functions:
  Percent   Name
    5.39%   SpinPause
    2.07%   ParMarkBitMap::mark_obj
    1.98%   ParallelCompactData::add_obj
    0.95%   GreyObjectsWalker_walkGreyObjects_e59a80a81022647b793f2f995d251cf18cbcbab4
    0.79%   ControlFlowGraph_identifyBlocks_91c6bd2376323c10cda627f1ed5130f90d88a82f
    0.69%   EconomicMapImpl_compareKeys_139d60c35d64f232b5b9fac87391585f45801e09
    0.67%   ArrayList_add_43f6399c3b46d50c69e7ebaee5e44ba3b6a870f3
    0.58%   ControlFlowGraph_identifyBlock_7f27028f31036b771721050156eba6ce33899dfa
    0.55%   SchedulePhase$Instance_scheduleEarliestIterative_f11f1d84d698be305ec40ea50fa995f7185d393f
    0.54%   EconomicMapImpl_find_70589f86ac2abbc40566645a1af83af4aa5c89f0

Hot generated code:
  Percent   Compile Id  Name
    1.97%         2557  sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa(int, long, int, boolean)
    1.86%         3101  org.apache.fop.render.ps.PSRenderer.renderText(org.apache.fop.area.inline.AbstractTextArea, java.lang.String, int[])
    1.27%               Interpreter
    1.12%         3353  org.apache.fop.fo.FObj.addChildNode(org.apache.fop.fo.FONode)
    0.75%         3112  java.text.DigitList.set(boolean, double, int, boolean)
    0.63%         1357  org.apache.fop.fo.properties.PropertyMaker.get(int, org.apache.fop.fo.PropertyList, boolean, boolean)
    0.61%         3145  org.apache.fop.layoutmgr.inline.TextLayoutManager.getNextKnuthElements(org.apache.fop.layoutmgr.LayoutContext, int)
    0.51%         3110  java.text.DecimalFormat.subformat(java.lang.StringBuffer, java.text.Format$FieldDelegate, boolean, boolean, int, int, int, int)
    0.34%         2787  org.apache.fop.layoutmgr.inline.TextLayoutManager.addAreas(org.apache.fop.layoutmgr.PositionIterator, org.apache.fop.layoutmgr.LayoutContext)
    0.32%         2738  org.apache.fop.layoutmgr.inline.TextLayoutManager.createTextArea(org.apache.fop.traits.MinOptMax, int, org.apache.fop.layoutmgr.LayoutContext, int, int, int, boolean)

sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa(int, long, int, boolean)
0x7f7a69251e80-0x7f7a69252d38 (samples=613, period=2591391597)
Hot region 1
       0x7f7a69252082:  sub     ecx, edi        ; sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa:252
       0x7f7a69252084:  mov     edx, ecx        ; sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa:287
       0x7f7a69252086:  add     edx, r13d
       0x7f7a69252089:  add     edx, dword ptr [rax + rsi*4 + 0x10]     ; sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa:307
 0.16% 0x7f7a6925208d:  cmp     edx, 0x40       ; sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa:330
       0x7f7a69252090:  jge     0x7f7a69252a62
       0x7f7a69252096:  sub     r10d, r14d      ; sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa:372
       0x7f7a69252099:  sub     r10d, edi       ; sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa:259
       0x7f7a6925209c:  mov     edi, r10d       ; sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa:294
       0x7f7a6925209f:  add     edi, dword ptr [rax + rbx*4 + 0x10]
       0x7f7a692520a3:  inc     edi
       0x7f7a692520a5:  cmp     edi, 0x40
       0x7f7a692520a8:  jge     0x7f7a69252c6f
 ...
```

Every piece of generated code is disassembled and broken into hot regions where ticks are clustered.  This gives a general
overview of the hot parts of the execution.  Other options to profhot give more control over how this is printed.
